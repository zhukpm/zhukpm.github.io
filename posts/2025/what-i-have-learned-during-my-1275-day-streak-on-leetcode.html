<!DOCTYPE html>

<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-N19THDZVEY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-N19THDZVEY');
</script>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism.min.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" rel="stylesheet"/>
<link href="/theme/css/style.css" rel="stylesheet"/>
<link href="/theme/css/fonts.css" rel="stylesheet"/>
<meta content="width=device-width,initial-scale=1.0" name="viewport"/>
<title>What I have learned during my 1275+ day streak on LeetCode – Viacheslav Zhukov</title>
<meta charset="utf-8"/>
<meta content="leetcode, algorithms, data structures, problem solving, coding interview preparation, leetcode tips, leetcode tricks" name="keywords"/>
<meta content="https://vzhukov.dev/og-image.png" property="og:image"/>
<meta content="I started my LeetCode journey on… Well, honestly, I don’t even remember the exact date already. I had several attempts to start solving problems on LeetCode every day, but I never managed to keep it up for more than a few weeks. Until 2022, when I finally managed to …" name="description"/>
<meta content="Algorithms" name="tags"/>
<meta content="Data Structures" name="tags"/>
<meta content="LeetCode" name="tags"/>
<meta content="#1F3683" name="theme-color"/>
<link href="https://vzhukov.dev/logo_rounded.png" rel="apple-touch-icon" sizes="192x192"/>
<link href="https://vzhukov.dev/logo_rounded.png" rel="icon"/>
<link href="https://vzhukov.dev/posts/2025/what-i-have-learned-during-my-1275-day-streak-on-leetcode" rel="canonical"/><script type="application/ld+json">{"@context": "https://schema.org", "@type": "BreadcrumbList", "itemListElement": [{"@type": "ListItem", "position": 1, "name": "Viacheslav Zhukov", "item": "https://vzhukov.dev"}, {"@type": "ListItem", "position": 2, "name": "Posts", "item": "https://vzhukov.dev/posts"}, {"@type": "ListItem", "position": 3, "name": "2025", "item": "https://vzhukov.dev/posts/2025"}, {"@type": "ListItem", "position": 4, "name": "What i have learned during my 1275 day streak on leetcode", "item": "https://vzhukov.dev/posts/2025/what-i-have-learned-during-my-1275-day-streak-on-leetcode.html"}]}</script><script type="application/ld+json">{"@context": "https://schema.org", "@type": "Article", "author": {"@type": "Person", "name": "Viacheslav Zhukov"}, "publisher": {"@type": "Organization", "name": "Viacheslav Zhukov", "logo": {"@type": "ImageObject", "url": "https://vzhukov.dev/logo_rounded.png"}}, "headline": "What I have learned during my 1275+ day streak on&nbsp;LeetCode", "about": "Software Engineering", "datePublished": "2025-07-30 23:20"}</script></head>
<body class="home" id="index">
<header class="body" id="banner">
<h1><a href="https://vzhukov.dev/">Viacheslav Zhukov</a></h1>
<p>Notes on AI, ML, Software Engineering and Math</p>
</header>
<nav id="menu"><ul>
<li><a href="/">Posts</a></li>
<li><a href="https://vzhukov.dev/javascript-memes">Javascript Memes</a></li>
<li><a href="https://vzhukov.dev/cv"><span class="caps">CV</span></a></li>
</ul></nav>
<main data-pagefind-body="" id="content">
<header>
<h1 class="entry-title" data-pagefind-meta="title">
<a href="https://vzhukov.dev/posts/2025/what-i-have-learned-during-my-1275-day-streak-on-leetcode" rel="bookmark" title="Permalink to What I have learned during my 1275+ day streak on LeetCode">What I have learned during my 1275+ day streak on LeetCode</a>
</h1>
</header>
<section class="entry-content key-text-content">
<p>I started my LeetCode journey on… Well, honestly, I don’t even remember the exact date already. I had several 
attempts to start solving problems on LeetCode every day, but I never managed to keep it up for more than a few weeks. 
Until 2022, when I finally managed to establish a daily routine that I have been following for over 1275 days now. </p>
<p>I have learned a lot during this time. Like with everything else, the more you practice, the better you understand 
the subject. And it turns out that solving problems on LeetCode is not just about algorithms and data structures. 
Well, they do matter, of course, but there are many other <em>not-so-obvious</em> things that can really help you along 
the way.</p>
<p><img alt="LeetCode Profile Image of Viacheslav Zhukov" class="image-process-crisp" src="https://vzhukov.dev/images/005/derivatives/crisp/1x/perrymason-leetcode-profile.png" srcset="https://vzhukov.dev/images/005/derivatives/crisp/1x/perrymason-leetcode-profile.png 1x, https://vzhukov.dev/images/005/derivatives/crisp/2x/perrymason-leetcode-profile.png 2x, https://vzhukov.dev/images/005/derivatives/crisp/4x/perrymason-leetcode-profile.png 4x"/></p>
<div class="caption">
<p>A snapshot of my <a href="https://leetcode.com/u/perrymason/">LeetCode profile</a></p>
</div>
<h2>Give yourself time to gain experience</h2>
<p>You want to become able to solve <a href="https://leetcode.com/problems/partition-array-for-maximum-xor-and-and/description/">hards</a> 
in 30 minutes? Great! But it won’t happen overnight. You literally have to establish certain neural connections in your brain, 
and it takes time. The more you practice, the clearer the patterns become to you. And that’s where you start thinking at 
more abstract levels, which is the key to solving problems faster.</p>
<p>Start with easy problems, cover multiple topics, algorithms, and data structures. Familiarize yourself with the most common 
concepts. Fortunately, this set is quite finite — it’s not <a href="https://en.wikipedia.org/wiki/Differentiable_function">the set of functions continuously differentiable on [0, 1]</a>.
I’d say, “pass the first level”. After that, gradually increase the difficulty by moving to mediums, repeat the process, form new connections,
and finally advance to hards. </p>
<p>It’s possible. It just takes time.</p>
<h2>Programming languages do differ</h2>
<p>While many programming languages share similar concepts and are even considered “high-level” and “general-purpose”,
there are still significant differences between them. And it’s not solely about syntax. Take, for example, a standard
collections library. Python offers you a <code>list</code>, a <code>set</code>, and a <code>dict</code>, and that’s pretty much it. C++, on the other
hand, is much richer: it has <code>vector</code>, <code>array</code>, <code>unordered_map</code>, <code>map</code> (“sorted” map, as you may guess; based on
Red-Black or other kinds of trees), <code>unordered_set</code>, <code>set</code>, <code>priority_queue</code>, and many more. Of course, Python also
has all of these, but the way you work with them is different — for priority queues, for instance, you have to use the <code>heapq</code> module together with a <code>list</code>; for sorted sets, you have to use <code>SortedSet</code> from the <code>sortedcontainers</code> 
module, etc.
The difference becomes even more pronounced when you start looking at more advanced features like modular arithmetic.
Compare the following:</p>
<pre><code class="language-python"># Python
&gt;&gt;&gt; -12 % 5
3
</code></pre>
<pre><code class="language-cpp">// C++
cout &lt;&lt; -12 % 5 &lt;&lt; endl; // -2
</code></pre>
<p>In C++ you also have to be careful with integer overflows:</p>
<pre><code class="language-python"># Python
&gt;&gt;&gt; 1 &lt;&lt; 32
4294967296
</code></pre>
<pre><code class="language-cpp">// C++
cout &lt;&lt; (1 &lt;&lt; 32) &lt;&lt; endl;
/*
Runtime Error: UndefinedBehaviorSanitizer: undefined-behavior :
shift exponent 32 is too large for 32-bit type 'int'
*/
</code></pre>
<p>And understand how <em>exactly</em> parameters are passed to functions:</p>
<pre><code class="language-python"># Python
def f(c: list) -&gt; list:
    c.append(1)
    return c

c = []

import time
s = time.perf_counter()
for _ in range(5000):
    c = f(c)
print(time.perf_counter() - s) # 0.00032
</code></pre>
<pre><code class="language-cpp">// C++
vector&lt;int&gt; f(vector&lt;int&gt; c) {
    c.push_back(1);
    return c;
}

int main() {
    vector&lt;int&gt; c;

    auto start = chrono::high_resolution_clock::now();
    for (int i = 0; i &lt; 5000; ++i) {
        c = f(c);
    }
    auto end = chrono::high_resolution_clock::now();
    cout &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() / 1000000.0 &lt;&lt; endl; // 0.042879
}
</code></pre>
<p>Notice the huge difference in performance. In Python, the function <code>f</code> modifies the list <code>c</code> in place, while in C++ it creates a new copy of the vector every time you call <code>f</code>. So the complexity of the C++ code is actually <span class="math">\(O(n^2)\)</span>, while in Python it is <span class="math">\(O(n)\)</span>.
Here’s a “fix” for the C++ code:</p>
<pre><code class="language-cpp">// C++
vector&lt;int&gt;&amp; f(vector&lt;int&gt;&amp; c) {
    c.push_back(1);
    return c;
}
// now the time is 0.00018
</code></pre>
<p>Learning your language’s peculiarities is an essential part here.</p>
<h2>Learn your language’s collections framework</h2>
<p>Data structures in general and collections in particular are the most important part of your arsenal. So learning
them is crucial. You should know what you have available, how to use them, what their time and memory complexities are,
and what their <span class="caps">API</span> is. Fortunately, the set of collections is rather small (arrays, sets, maps, queues, stacks, heaps, linked lists,
sorted variants of the previous ones, and a couple more), and most languages have a standard library that provides
pretty much all of them. Familiarize yourself with the collections framework of your language, and don’t spend too much time
(or brain effort) on remembering how to create a max-heap in Python or how to create a sorted set with a custom comparator
in C++.</p>
<h2>Constants in time <span class="amp">&amp;</span> memory complexities do matter</h2>
<p>That’s one of my favorite parts!</p>
<p>Pretty much everyone (every book, every course, every blog post) tells you that time and memory complexities are a
really important part, and you should learn this <span class="math">\(O\)</span> notation and understand what it means and how to use it. 
First of all, that’s true. And you have to learn it. But there is one more thing that is often overlooked: 
this notation (more precisely, when someone makes calculations using this notation) usually omits constants in final 
complexities. They tell you — “we’re interested in the asymptotic behavior, how the complexity grows with the 
input size, and not the exact number of operations”. Or even “these two algorithms both have <span class="math">\(O(n)\)</span> complexity, 
so they’re equivalent in memory/execution time”. And this one — it’s not true.</p>
<p>Why does it happen? Constants in time and memory complexities can show you <em>what exactly</em> is going on under the hood.</p>
<p>Let’s consider the following problem:</p>
<blockquote>
<p>Given an array of integers from 1 to 1000 (the length of the array is <span class="math">\(10^5\)</span>), find the most frequent number. 
If there are multiple such numbers, return the smallest one.</p>
</blockquote>
<p>To solve this problem we need to find counts for each number, then find the largest count, and pick the smallest number 
among those that have this count. But how do we find the counts? In C++ we can use an <code>unordered_map</code> to store the 
counts. What is <code>unordered_map</code>? It’s a hash table (a hash map), which means that it has an average time complexity of 
<span class="math">\(O(1)\)</span> for insertions and lookups. Looks great, right? But what happens under the hood?</p>
<p>When we insert a new element into the hash table, </p>
<ul>
<li>it calculates the hash of the key, </li>
<li>finds the bucket where this key should be stored, </li>
<li>and then inserts the key-value pair into that bucket.</li>
</ul>
<p>There could also be collisions, which means that two different keys can end up in the same bucket. In this case, 
the hash table has to handle the collision (usually by chaining or open addressing).</p>
<p>That’s a lot of “internal stuff” happening, and it takes time. So <em>the constant</em> of <code>unordered_map</code> operations is 
quite high. </p>
<p><code>vector</code>, on the other hand, is a dynamic array. It has a much simpler structure: it just stores elements in a 
contiguous block of memory. When we edit an element in a <code>vector</code>, it just accesses the memory location of that 
element and modifies it. A lot simpler than in <code>unordered_map</code>. And the constant of <code>vector</code> operations is much lower 
than that of <code>unordered_map</code>, while the complexity is the same: <span class="math">\(O(1)\)</span> for both.</p>
<p>To use <code>vector</code> in this problem we can leverage the fact that the numbers are in a fixed range (from 1 to 1000).</p>
<p>How does it look in practice?</p>
<pre><code class="language-cpp">int main() {
    const int n = 100000;
    vector&lt;int&gt; arr(n);
    for (int i = 0; i &lt; n; ++i) {
        arr[i] = rand() % 1000 + 1; // fill with random numbers from 1 to 1000
    }

    // Using unordered_map
    auto start = chrono::high_resolution_clock::now();
    unordered_map&lt;int, int&gt; counts_map;
    for (int num : arr) {
        counts_map[num]++;
    }
    auto end = chrono::high_resolution_clock::now();

    cout &lt;&lt; "Time taken using unordered_map: "
         &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() / 1000000.0
         &lt;&lt; " seconds" &lt;&lt; endl;

    // Using vector
    start = chrono::high_resolution_clock::now();
    vector&lt;int&gt; counts_vector(1001, 0); // 1001 to include 1000
    for (int num : arr) {
        counts_vector[num]++;
    }
    end = chrono::high_resolution_clock::now();

    cout &lt;&lt; "Time taken using vector: "
         &lt;&lt; chrono::duration_cast&lt;chrono::microseconds&gt;(end - start).count() / 1000000.0
         &lt;&lt; " seconds" &lt;&lt; endl;
}
</code></pre>
<p>And it outputs something like this:</p>
<pre><code class="language-text">Time taken using unordered_map: 0.001208 seconds
Time taken using vector: 0.000149 seconds
</code></pre>
<p><strong>Almost 10 times faster</strong>! While “the complexity” of both solutions is <span class="math">\(O(n)\)</span>. Moreover, the memory usage is also lower: <code>unordered_map</code> uses more memory due to its internal structure, while <code>vector</code> just stores the counts in a 
contiguous block of memory.</p>
<p>Hacks like this can significantly improve your solution’s performance and avoid TLEs.</p>
<h2>In 90% of cases, it’s about the right data structure</h2>
<p>A lot of problems on LeetCode are solvable using one and only one data structure that fits the problem perfectly,
be it a stack, a queue, a set, a map, or something else. Each data structure has a certain purpose, and
provides you with a specific <span class="caps">API</span> — what you can do with it, how you can access elements, manipulate them, and so on. 
It also provides you with complexities for these operations, which is useful when assessing the performance of your solution.</p>
<p>The choice really depends on what you want to achieve, what information you’d like to know about the data. For example,
to find the most frequent number in an array, we’d like to know how many times each number appears in the array. It
means that we need to store the counts of each number, and we need a data structure that allows us to do that
efficiently. Going through the array, and taking numbers one after another, we want to “put them into corresponding
boxes” for which we can instantly get the size. This is a perfect use case for a hash map (or a dictionary,
or an unordered map, or whatever you call it in your language).</p>
<p>The thing is, <strong>it works the opposite way too</strong>: if you have a problem, and you don’t know how to solve it, try going
through the list of data structures you know, and see if any of them can help you. Start asking questions like:</p>
<blockquote>
<p>Okay, maybe I can use a stack here? Will it help me if I store elements on top of each other, and then pop the last
one when I need it? I can compare a new element with the last one in the stack, do some magic and create a sorted 
stack. Will it help me?</p>
</blockquote>
<p>More complicated problems may require more complex data structures, like trees, 
<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heaps</a>, graphs, or <a href="https://de.wikipedia.org/wiki/Trie">tries</a>. 
But the idea remains the same.</p>
<p>Even more complicated problems are solved using a combination of data structures. However, they rarely interoperate
with each other, and you usually break the problem into smaller consecutive pieces, each of which can be solved using
one and only one data structure. But more about that later.</p>
<p><em><span class="caps">PS</span>: The same applies to algorithms.</em></p>
<h2>In the other 90% —- it’s about finding the right invariant</h2>
<p>An <a href="https://en.wikipedia.org/wiki/Invariant_(mathematics)#Invariants_in_computer_science">invariant</a> is a condition 
that holds true at a certain point in your program. It can be a property of the data structure (e.g., that your data 
structure is sorted, or that it contains unique elements only), or a property of the algorithm (e.g., that at the 
beginning of each iteration, the algorithm has processed all elements before/after the current one).</p>
<p>It’s easier to approach problems by considering different invariants, and then trying to pick the one that actually 
holds true. </p>
<p>Suppose we’re solving the next one: <a href="https://leetcode.com/problems/house-robber/">198. House Robber</a>. In this problem, 
we can’t rob two adjacent houses, while we want to maximize the amount of money we can rob. We’re starting from the 
first house, and we can either rob it or skip it. If we rob it, we can’t rob the second house, but we can rob the third 
one. If we skip it, we can move to the second house and repeat the process. So a possible invariant here would be that 
at each step, we’d like to already know the maximum amount of money we can rob <em>starting</em> from any house <em>after</em> the 
current one. If it holds true, we can easily build a solution:</p>
<pre><code class="language-cpp">money[i] = max(
  money[i + 1],             // skip the current house, and move to the next one
  money[i + 2] + houses[i]  // rob the current house and skip the next one
);
</code></pre>
<p>The next question is: how do we ensure this invariant? Well, here it only means that we should start from the last 
house and move backwards to the first one, calculating the maximum amount of money we can rob at each step, since the 
solution for the very last house is trivial (we can rob it, and that’s it).</p>
<p>Of course, this is plain <span class="caps">DP</span> (dynamic programming); and yes, DPs are all about invariants. But not only DPs. Graph 
algorithms, greedy algorithms, and many other algorithms also rely on invariants.</p>
<h2>Start by thinking abstractly, and think “in-reverse”</h2>
<p>Solve the problem “on a high level” first. Suppose that you <em>can do certain things</em>, you will figure out the real 
implementation later, now just think about them as <em>building blocks</em>. Break the problem into smaller steps 
(that later can be implemented as functions).</p>
<p>These <em>building blocks</em> are your <em>arsenal</em>, your higher-level <em>tools</em>. The more <em>tools</em> you know, the faster you’ll 
be able to solve problems. These tools could be anything: an algorithm, a smaller problem that you have seen before, 
an operation over a data structure, a mathematical trick, or whatever.</p>
<p>The second part, “think in reverse”, means that it’s usually easier to think about the result you want to achieve 
first, and then move backwards to the initial state. The all-time question here is “how can I get it?” — what are the 
steps to get the data I need?</p>
<p>Consider the same problem about finding the <em>smallest</em> most frequent number in an array:</p>
<blockquote>
<p>So, I need to find the smallest most frequent number in an array. How can I get it? I may need two things here: 
the count of each element, and the highest frequency. The latter one is easy to get if I have the counts. 
So, how do I get the counts? I can use a hash map — I’ll iterate over the array, and for each element, 
I’ll increment the count in the hash map, starting from 0. Then I can find the maximum count, obviously. 
Then I can iterate over the elements again, and whenever I see an element with the maximum count (that I just 
obtained in the second step), I can update my answer if it’s smaller than the current result. Ah, I also have to 
initialize my answer somehow… Okay, I’ll do that — either with a very large number, or with the first element in 
the hash map that has the maximum count. 
Can I optimize this solution somehow? Oh, I can! I can use a vector of size 1001 instead of a hash map to speed up 
the whole process! Awesome!</p>
</blockquote>
<p>Brainteasers are the only exception to this rule, probably, as they usually require you to find some “Aha!” approach. 
But it definitely works for most other problems on LeetCode.</p>
<h2>Brute-force solutions are also valid solutions</h2>
<p>Brute-force solutions are often the first thing that comes to mind when you see a problem. At least, they should be. 
If you can’t come up with a brute-force solution, then “<em>Houston, we have a problem!</em>” — you probably don’t understand 
the problem well enough (or the topic it covers). Try reading the problem definition several times, pay attention to 
terms and constraints, or anything else that is in <strong>bold</strong>. If you still have no clue — hints or other people’s 
solutions can really help you here.</p>
<p>However, this section is about the <em>validity</em> of brute-force solutions. <em>They are valid</em>. They just may give you a 
<span class="caps">TLE</span> or <span class="caps">MLE</span>. But it depends on the problem constraints, and (in reality) the programming language you use. It is funny 
to see sometimes, but quadratic brute-force solutions in C++ can pass the tests, while the same solution in Python 
will give you a <span class="caps">TLE</span>.</p>
<p>Other cases, like this one - 
<a href="https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/">2044. Count Number of Maximum Bitwise-<span class="caps">OR</span> Subsets</a> — 
Me personally, I don’t know how to solve it without brute-force (and whether it’s even possible or not). So I just, 
first, find the maximum bitwise <span class="caps">OR</span> — the <span class="caps">OR</span> of all elements in the array, and then I iterate over all possible subsets (<span class="math">\(2^n\)</span> cases) and count how many of them have the same <span class="caps">OR</span> as the maximum one:</p>
<pre><code class="language-cpp">class Solution {
public:
    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {
        int r = 0;
        for (int v : nums) r |= v;
        return count(0, 0, nums, r);
    }

    int count(int cur, int i, const vector&lt;int&gt;&amp; nums, int t) {
        if (i == nums.size()) return cur == t;
        return count(cur, i + 1, nums, t) + count(cur | nums[i], i + 1, nums, t);
    }
};
</code></pre>
<p>And you know what? It works! It passes all tests, and it’s even better than most other C++ solutions:</p>
<p><img alt="Solution stats for 2044. Count Number of Maximum Bitwise-OR Subsets" class="image-process-article-image" src="https://vzhukov.dev/images/005/derivatives/article-image/2044-solution-stats.png"/></p>
<p><em>Hint: if the problem constraints say that the input length is at most 20, then you most probably should use a 
brute-force solution.</em></p>
<h2>Don’t be afraid of failing</h2>
<p>It’s <span class="caps">OK</span> to not know everything. Moreover, you even shouldn’t know everything. Thousands of people, scientists,
and engineers, have been working on algorithms and data structures for decades. This huge amount of knowledge is
available to you (thanks to the Internet and, now, to LLMs), and you can use it. You <em>should</em> remember the most
crucial ones, like stacks and queues, <span class="caps">BFS</span>/<span class="caps">DFS</span>, Dijkstra’s algorithm (ideally), but you don’t have to memorize things
like “how to implement a <a href="https://en.wikipedia.org/wiki/Segment_tree">segment tree</a> with lazy propagation”.</p>
<p>What is more important here is to become able to <em>implement such algorithms</em> from their descriptions and pseudocode.</p>
<p>For example, this one: <a href="https://leetcode.com/problems/reconstruct-itinerary/">332. Reconstruct Itinerary</a>. Ideally,
you should solve it with <a href="https://en.wikipedia.org/wiki/Eulerian_path">Eulerian Circuit</a>. It would be great if you
can notice that, but it’s ok to not know how exactly to implement it. You can read ideas behind existing approaches,
and try to implement it yourself. Check out the internet for descriptions and pseudocodes — there are usually
<a href="https://cp-algorithms.com/graph/euler_path.html">a lot of helpful materials</a>. If it still doesn’t work — ok, you
tried, you did your best — check out published solutions, and try to understand how they work. That’s the
learning process.</p>
<p>A rule of thumb here is to limit yourself to some time for a problem, and if you can’t solve it in that time, try
looking at hints first, then at <em>titles</em> of existing solutions, and finally at the solutions themselves. I usually
give myself about 2 hours before looking at hints. The thing is, I do it less and less often now.</p>
<p>Here are some statistics about time taken to solve problems for the last half a year (not all problems were logged, unfortunately):</p>
<pre><code class="language-text">Total tasks: 163
Average time per task: 22.68 minutes
Percentiles: 25% = 6.00, 50% = 12.00, 75% = 28.00
Total time spent: 3697.00 minutes (61.62 hours)
Shortest task: 1.00 minute
Longest task: 224.00 minutes
</code></pre>
<p><img alt="Time statistics for LeetCode problems solved by Viacheslav Zhukov" class="image-process-large-photo" sizes="(min-width: 1200px) 800px, (min-width: 992px) 650px, (min-width: 768px) 718px, 100vw" src="https://vzhukov.dev/images/005/derivatives/large-photo/800w/task-time-distribution.png" srcset="https://vzhukov.dev/images/005/derivatives/large-photo/600w/task-time-distribution.png 600w, https://vzhukov.dev/images/005/derivatives/large-photo/800w/task-time-distribution.png 800w, https://vzhukov.dev/images/005/derivatives/large-photo/1600w/task-time-distribution.png 1600w"/></p>
<h2>Consistency is key</h2>
<p><img alt="Viacheslav Zhukov 1000 LeetCode streak" class="image-process-article-image" src="https://vzhukov.dev/images/005/derivatives/article-image/perrymason-1000-streak.png"/></p>
<p>Just as LeetCode tells you, consistency is the key. Forming new neural connections takes time. And it’s much easier to
do it gradually, day by day, than trying to learn everything in a week before the interview and burn out and oversleep the
meeting you were preparing for. It also helps you to retain the knowledge you have already gained, as we, humans, tend to
forget things we don’t use regularly.</p>
<h2>After all</h2>
<p>Don’t forget about the trivials:</p>
<ul>
<li>estimate the time and memory complexities;</li>
<li>check corner cases. Think what can go wrong, and which pieces of your solution are the most prone to fail (hint: indexing, nested for loops, etc). Fortunately, LeetCode allows you to add custom test cases (though they restrict it to 8 currently);</li>
<li>think about an algorithm and data structures before writing the code. It’s easier to rewrite code in your head than in the editor. Think abstractly, establish a hierarchy, break everything into functions, and <strong>only then</strong> implement it in code;</li>
<li>proofread what you have written. Use appropriate variable names, pay attention to indexing, fix typos and syntax errors, and so on.</li>
</ul>
<h2>Conclusion</h2>
<p>A lot of stuff… And only one question: Why? It’ll take some time to explain, but the short answer is: fun! I just like 
solving leetcode every day, and I hope these tips will help you to enjoy it too. I’ll cover more about the pros and cons of 
solving problems on LeetCode every day in the next post. </p>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
</section>
<footer class="post-info">
    Written by Viacheslav Zhukov in <a href="https://vzhukov.dev/posts/category/software-engineering">Software Engineering</a> on
    <time class="published" datetime="2025-07-30T23:20:00+02:00">        30th
July 2025
    </time>
</footer>
<section class="tags">
<a href="https://vzhukov.dev/posts/tag/algorithms">Algorithms</a>
<a href="https://vzhukov.dev/posts/tag/data-structures">Data Structures</a>
<a href="https://vzhukov.dev/posts/tag/leetcode">LeetCode</a>
</section>
</main>
<aside id="sidebar">
<div class="sidebar-block">
<img alt="Photo of Viacheslav Zhukov" class="profile-photo" src="https://vzhukov.dev/profile_photo.png"/>
<p>Doing AI &amp; ML engineering @ <a href="https://www.linkedin.com/company/toloka/" rel="noopener noreferrer" target="_blank" title="Toloka">Toloka</a></p>
<p> Occasional blogger, researcher, and math lover.</p>
<div class="social-icons">
<a href="https://www.linkedin.com/in/zhukpm/" rel="noopener noreferrer" target="_blank" title="LinkedIn profile of Viacheslav Zhukov">
<img alt="LinkedIn icon" class="social-icon" src="https://www.linkedin.com/favicon.ico"/>
</a>
<a href="https://github.com/zhukpm" rel="noopener noreferrer" target="_blank" title="GitHub profile of Viacheslav Zhukov">
<img alt="GitHub icon" class="social-icon" src="https://github.com/favicon.ico"/>
</a>
<a href="https://stackoverflow.com/users/6372685/viacheslav-zhukov" rel="noopener noreferrer" target="_blank" title="StackOverflow profile of Viacheslav Zhukov">
<img alt="StackOverflow icon" class="social-icon" src="https://stackoverflow.com/favicon.ico"/>
</a>
<a href="https://leetcode.com/perrymason/" rel="noopener noreferrer" target="_blank" title="LeetCode profile of Viacheslav Zhukov">
<img alt="LeetCode icon" class="social-icon" src="https://leetcode.com/favicon.ico"/>
</a>
</div>
</div>
<div class="sidebar-block">
<h2>Privacy</h2>
<p>
                        This site uses Google Analytics to understand visitor traffic and improve content.
                        It collects anonymous data like country, language, and pages visited - no personal
                        information. By continuing to browse, you agree to this minimal tracking.
                        <a href="https://www.google.com/search?q=is+google+analytics+tracking+safe" rel="noopener noreferrer" target="_blank">Read more</a>.</p>
</div>
<div class="sidebar-block">
<h2>Categories</h2>
<ul>
<li>
<a href="https://vzhukov.dev/posts/category/math">Math (2)</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/category/natural-language-processing">Natural Language Processing (2)</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/category/machine-learning">Machine Learning (1)</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/category/software-engineering">Software Engineering (1)</a>
</li>
</ul>
</div>
<div class="sidebar-block">
<h2>Recent posts</h2>
<ul>
<li>
<a href="https://vzhukov.dev/posts/2025/fitting-the-player-ranking-model-a-maximum-likelihood-approach">Fitting the Player Ranking Model: A Maximum Likelihood Approach</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/2025/what-i-have-learned-during-my-1275-day-streak-on-leetcode">What I have learned during my 1275+ day streak on LeetCode</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/2025/mathematical-model-for-player-ranking">Mathematical Model for Player Ranking</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/2025/approximating-skills-of-table-tennis-players-using-normal-distribution-introduction">Approximating Skills of Table Tennis Players Using Normal Distribution. Introduction</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/2023/text-classification-challenge-with-extra-small-datasets-fine-tuning-versus-chatgpt">Text classification challenge with extra-small datasets: Fine-tuning versus ChatGPT</a>
</li>
<li>
<a href="https://vzhukov.dev/posts/2023/choosing-the-best-architecture-for-your-text-classification-task">Choosing the best architecture for your text classification task</a>
</li>
</ul>
</div>
</aside>
<footer id="site-footer">
<p>Built with <a href="https://getpelican.com/" rel="noopener noreferrer" target="_blank">Pelican</a> using <a href="https://python.org/" rel="noopener noreferrer" target="_blank">Python</a> and <a href="https://github.com/hrw/pelican-haerwu-theme/" rel="noopener noreferrer" target="_blank">Haerwu theme</a>.</p>
<p>Copyright by Viacheslav Zhukov. Licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener noreferrer" target="_blank">CC BY-NC-SA 4.0</a>.</p>
</footer>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script src="https://cdn.jsdelivr.net/combine/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js,npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
</body>
</html>